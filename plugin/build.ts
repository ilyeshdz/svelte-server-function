import { SyntaxKind } from "ts-morph";
import { tsProject } from "./tsmorph-project";
import { globFiles, readFile, writeFile } from "./utils/file-system";
import { createHash } from "crypto";
import { FileBackedCache } from "./utils/cache";

export async function setupEndpointHandler(rpcEndpoint: string) {
  const code = await readFile("./plugin/modules/handler.ts");
  let endpointAsFilePath = `./src/routes${rpcEndpoint}/+server.ts`;

  await writeFile(endpointAsFilePath, code);
}

export async function generateStaticImportMap(cache: FileBackedCache) {
  const manifest = cache.toObject();

  const imports: string[] = [];
  const entries: string[] = [];

  let index = 0;

  for (const fn of Object.values(manifest)) {
    const importPath = fn.filePath.replace("$lib/", "$lib/"); // conserve en alias
    const variableName = `mod${index++}`;

    imports.push(`import * as ${variableName} from '${importPath}';`);
    entries.push(`  "${fn.filePath}": ${variableName},`);
  }

  const content = `// ⚠️ Auto-generated by svelte-server-function plugin
${imports.join("\n")}

export const modules = {
${entries.join("\n")}
};`;

  await writeFile("src/lib/.svelte-server-functions-map.ts", content);
}

export async function generateEndpointManifest(
  options: string | string[],
  cache: FileBackedCache
) {
  const patterns = Array.isArray(options) ? options : [options];
  let allFiles: string[] = [];
  for (const pattern of patterns) {
    const files = await globFiles(pattern);
    allFiles.push(...files);
  }

  for (const file of allFiles) {
    const code = await readFile(file);
    const source = tsProject.createSourceFile(file, code, { overwrite: true });

    source.getExportedDeclarations().forEach((decls, exportName) => {
      for (const decl of decls) {
        const fnDecl = decl.getFirstChildByKind(SyntaxKind.FunctionDeclaration);
        const arrowFn = decl.getFirstChildByKind(SyntaxKind.ArrowFunction);

        if (fnDecl || arrowFn) {
          const id = createHash("sha256")
            .update(`${file}::${exportName}`)
            .digest("hex")
            .slice(0, 8);
          const filePath = file
            .replace(/^src\/lib/, "$lib")
            .replace(/\.ts$/, "");

          cache.set(id, { id, filePath, exportName });
        }
      }
    });
  }

  await cache.persist();
  await generateStaticImportMap(cache);
  return cache.toObject();
}
